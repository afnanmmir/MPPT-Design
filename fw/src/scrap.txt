 *      - When PWM held LOW, ENABLE is ON
 *          - Shorts across body diode of HIGH SIDE FET from ARR+ to BATT+, open other direction (TPs VSW, VBATT+)
 *          - Shorts across LOW SIDE FET in both directions (TPs VSW, GND)
 *      - When PWM held HIGH, ENABLE is ON
 *          - Shorts across body diode of LOW SIDE FET from GND to ARR+, open other direction (TPs GND, VSW)
 *          - Shorts across HIGH SIDE FET in both directions (TPs VSW, VBATT+)
 *      - When ENABLE is OFF
 *          - Shorts across body diode of HIGH SIDE FET from ARR+ to BATT+, open other direction (TPs VSW, VBATT+)
 *          - Shorts across body diode of LOW SIDE FET from GND to ARR+, open other direction (TPs GND, VSW)
 *      - When PWM is set to 50% duty, the logic analyzer verifies as much on SW1 and GND, and SW2 and VSW.

 /*
The overall structure of the larger system is as follows:

                          environment error
                                  |
                                  v
          --------------    --------------
target -> | controller | -> |plant/system| -> output
          --------------    --------------       |
               ^                                 |
               |                                 |
               ----------------------------------+ <- sensor error

The plant represents the process; an example is the following:

                            plant
                     ------------------
controller output -> |     op amp     | -> actual output
                     |       |        |
                     |       v        |
                     |    DC motor    |
                     |       |        |
                     |       v        |
                     | rotating shaft |
                     ------------------

The PID controller belongs to the controller box, and attempts
to modulate the effects of the plant to correct the output.

                controller
          ----------------------
          | Proportional term  |
target -> |         +          |
          |    Integral term   | -> controller output
          |         +          |
 error -> |   Derivative term  |
          |---------------------

Where total error is defined as `error = output - target`.
*/



PIDConfig_t PIDControllerTune(
    PIDConfig_t config,
    enum TuneMode mode,
    void (*plantFunction)(double input),
    double (*sensorFunction)(void),
    double desiredOutput,
    uint32_t msCycleDelay,
    uint32_t numCycles
) {

    double pMultiplier = 0.1;
    double iMultiplier = 0.1;
    double dMultiplier = 0.1;
    uint32_t convergenceID = 0;

    const uint8_t DIM_LENGTH = 20;
            /* Each iteration lasts numIterCycles. During this period, we use the
            PID controller to actuate our plant and try to minimize the error. */
    if (mode == ACCURACY) {
        double convergenceError = 1.0;
        /* For each iteration, we want to attempt a new set of PID terms. */
        for (uint32_t p = 0; p < DIM_LENGTH; ++p) {
            config.p = p * pMultiplier;
            for (uint32_t i = 0; i < DIM_LENGTH; ++i) {
                config.i = i * iMultiplier;
                for (uint32_t d = 0; d < DIM_LENGTH; ++d) {
                    config.d = d * dMultiplier;

                    /* Reset plant. */
                    double actualOutput = 0.0;
                    plantFunction(0.0);

                    /* Delay the cycle by msCycleDelay for the new input to propagate. */
                    ThisThread::sleep_for(msCycleDelay);

                    double outputHist[5] = {0.0};
                    uint32_t iter;
                    for (iter = 0; iter < numCycles; ++iter) {
                        outputHist[iter%5] = sensorFunction();
                        
                        /* This function does three things at once. 
                           1. It captures the current sensor value
                           2. Iterates the PID controller to generate a new setpoint
                           3. Sets the setpoint to the actuator, or the plant function. */
                        plantFunction(PIDControllerStep(config, desiredOutput, sensorFunction()));

                        /* Delay the cycle by msCycleDelay for the new input to propagate. */
                        ThisThread::sleep_for(msCycleDelay);
                    }
                    outputHist[numCycles%5] = sensorFunction();
                    double outputHistTailAvg = 
                        (outputHist[0] + 
                         outputHist[1] + 
                         outputHist[2] + 
                         outputHist[3] + 
                         outputHist[4]) / 5;

                    /* Evaluate the end error. */
                    double error = fabs(desiredOutput - outputHistTailAvg) / desiredOutput;
                    if (error < convergenceError) {
                        convergenceID = p << 16 | i << 8 | d;
                        convergenceError = error;
                    }
                }
            }
        }
    } else if (mode == SPEED) {
        uint32_t convergenceCycles = numCycles;
        /* For each iteration, we want to attempt a new set of PID terms. */
        for (uint32_t p = 0; p < DIM_LENGTH; ++p) {
            config.p = p * pMultiplier;
            for (uint32_t i = 0; i < DIM_LENGTH; ++i) {
                config.i = i * iMultiplier;
                for (uint32_t d = 0; d < DIM_LENGTH; ++d) {
                    config.d = d * dMultiplier;

                    /* Reset plant. */
                    plantFunction(0.0);

                    /* Delay the cycle by msCycleDelay for the new input to propagate. */
                    ThisThread::sleep_for(msCycleDelay);

                    double outputHist[5] = {0.0};
                    uint32_t iter;
                    for (iter = 0; iter < numCycles; ++iter) {
                        outputHist[iter%5] = sensorFunction();
                        double outputHistTailAvg = 
                            (outputHist[0] + 
                             outputHist[1] + 
                             outputHist[2] + 
                             outputHist[3] + 
                             outputHist[4]) / 5;

                    
                        /* This function does three things at once. 
                           1. It captures the current sensor value
                           2. Iterates the PID controller to generate a new setpoint
                           3. Sets the setpoint to the actuator, or the plant function. */
                        plantFunction(PIDControllerStep(config, desiredOutput, sensorFunction()));

                        /* Delay the cycle by msCycleDelay for the new input to propagate. */
                        ThisThread::sleep_for(msCycleDelay);
    
                        /* Evaluate convergence speed. */
                        if (fabs(desiredOutput - outputHistTailAvg) / desiredOutput < 0.05 && iter < convergenceCycles) {
                            convergenceID = p << 16 | i << 8 | d;
                            convergenceCycles = iter;
                            break;
                        }
                    }
                }
            }
        }
    }

    /* Set config. */
    config.p = ((convergenceID & 0xFF0000) >> 16) * pMultiplier;
    config.i = ((convergenceID & 0x00FF00) >> 8) * iMultiplier;
    config.d = ((convergenceID & 0x0000FF) >> 0) * dMultiplier;

    return config;
}